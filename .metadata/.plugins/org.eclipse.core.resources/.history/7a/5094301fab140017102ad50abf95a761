package visitor;

import java.util.ArrayList;
import java.util.List;

import ast.definiciones.DefFuncion;
import ast.definiciones.DefVariable;
import ast.expresiones.*;
import ast.sentencias.*;
import ast.tipos.*;
import visitor.util.VisitorTemplate;

public class VisitorComprobacionTipos extends VisitorTemplate {

	@Override
	public Object visit(AccesoArray accesoArray, Object o) {
		super.visit(accesoArray, o);
		accesoArray.setLValue(true);
		return null;
	}

	@Override
	public Object visit(AccesoCampo accesoCampo, Object o) {
		super.visit(accesoCampo, o);
		accesoCampo.setLValue(true);
		return null;
	}

	@Override
	public Object visit(Aritmetica a, Object o) {
		super.visit(a, o);
		a.setLValue(false);
		a.setTipo(a.getIzq().getTipo().aritmetica(a.getDer().getTipo()));
		if (a.getTipo() == null)
			a.setTipo(new TipoError(a,
					"No son compatibles los tipos de los operandos"));
		return null;
	}

	@Override
	public Object visit(Cast cast, Object o) {
		super.visit(cast, o);
		cast.setTipo(
				cast.getExpresion().getTipo().promocionaA(cast.getTipoCast()));
		if (cast.getTipo() == null)
			cast.setTipo(new TipoError(cast, "No son compatibles los tipos"));
		cast.setLValue(false);
		return null;
	}

	@Override
	public Object visit(Comparacion c, Object o) {
		super.visit(c, o);
		c.setLValue(false);
		c.setTipo(c.getIzq().getTipo().comparacion(c.getDer().getTipo()));
		if (c.getTipo() == null)
			c.setTipo(new TipoError(c,
					"No se puede comparar " + c.getIzq().getTipo()
							+ " con el tipo " + c.getDer().getTipo()));
		return null;
	}

	@Override
	public Object visit(LiteralCaracter literalCaracter, Object o) {
		literalCaracter.setLValue(false);
		return null;
	}

	@Override
	public Object visit(LiteralEntero literalEntero, Object o) {
		literalEntero.setLValue(false);
		return null;
	}

	@Override
	public Object visit(LiteralReal literalReal, Object o) {
		literalReal.setLValue(false);
		return null;
	}

	@Override
	public Object visit(Logica l, Object o) {
		super.visit(l, o);
		l.setLValue(false);
		l.setTipo(l.getIzq().getTipo().logica(l.getDer().getTipo()));
		if (l.getTipo() == null)
			l.setTipo(new TipoError(l, "Error lógico"));
		return null;
	}

	@Override
	public Object visit(MenosUnario menosUnario, Object o) {
		super.visit(menosUnario, o);
		menosUnario.setLValue(false);
		return null;
	}

	@Override
	public Object visit(Negacion negacion, Object o) {
		super.visit(negacion, o);
		negacion.setLValue(false);
		return null;
	}

	@Override
	public Object visit(Variable variable, Object o) {
		variable.setLValue(true);
		return null;
	}

	@Override
	public Object visit(Asignacion asignacion, Object o) {
		super.visit(asignacion, o);
		if (!asignacion.getVariable().getLValue())
			new TipoError(asignacion,
					"Se esperaba LValue, asignación -> " + this.getClass());
		if (!asignacion.getVariable().getLValue())
			asignacion.getVariable()
					.setTipo(new TipoError(asignacion, "mensaje"));
		asignacion.getVariable().setTipo(asignacion.getValor().getTipo()
				.promocionaA(asignacion.getVariable().getTipo()));
		if (asignacion.getVariable().getTipo() == null)
			asignacion.getVariable().setTipo(
					new TipoError(asignacion, "Error tipo asignacion"));
		return null;
	}

	@Override
	public Object visit(Lectura lectura, Object o) {
		for (Expresion e : lectura.getExpresiones()) {
			e.accept(this, o);
			if (!e.getLValue())
				new TipoError(lectura,
						"Se esperaba LValue, lectura -> " + this.getClass());
		}
		return null;
	}

	@Override
	public Object visit(Return r, Object o) {
		super.visit(r, o);
		return r.getExpresion().getTipo();
	}

	@Override
	public Object visit(DefFuncion defFuncion, Object o) {
		defFuncion.getTipo().accept(this, o);
		for (DefVariable d : defFuncion.getVariablesLocales())
			d.accept(this, o);
		for (Sentencia s : defFuncion.getCuerpo()) {
			Object tipoRetorno = s.accept(this, o);
			if (tipoRetorno != null)
				if (!((TipoFuncion) defFuncion.getTipo()).getRetorno()
						.equals(tipoRetorno))
					new TipoError(defFuncion,
							"No coinciden el tipo de la funcion con el tipo de retorno"
									+ this.getClass());
		}
		return null;
	}

	@Override
	public Object visit(Invocacion invocacion, Object o) {
		invocacion.getVariable().accept(this, o);
		List<Tipo> tipos = new ArrayList<>();
		for (Expresion e : invocacion.getExpresiones()) {
			e.accept(this, o);
			tipos.add(e.getTipo());
		}
		invocacion
				.setTipo(invocacion.getVariable().getTipo().parentesis(tipos));
		if (invocacion.getTipo() == null)
			invocacion.setTipo(
					new TipoError(invocacion, "Error tipo invocacion"));
		return null;
	}

	@Override
	public Object visit(SentenciaWhile sentenciaWhile, Object o) {
		sentenciaWhile.getCondicion().accept(this, o);
		if (!sentenciaWhile.getCondicion().getTipo().esLogico())
			sentenciaWhile.getCondicion()
					.setTipo(new TipoError(sentenciaWhile.getLinea(),
							sentenciaWhile.getColumna(), "Completar clase 8"));
		for (Sentencia e : sentenciaWhile.getSentencias())
			e.accept(this, o);
		return null;
	}
}